Rendering a bezier surface
rendering-a-bezier-surface
Previously I wrote a blog post about how to interpolate a bezier curve. A bezier curve helps us to create smooth lines, surfaces, type faces. A bezier surface is set of bezier curves that is used for imaging a part of something. Before rendering a bezier surface, I will mention about how to render something with Python programming language. I will demonstrate it by rendering a set of cubes, then I will create marbles that made of cubes. A marble will stay at position of an interpolated point of a bezier curve. I will create an optimized cube for making the drawing process easier.
 
- code -
%(examples/create_cube.py)s
- code -
 
The function returns diamond shapes. Set of diamond shapes, ordered in correct way, will be painted to an image file in Python or to a canvas on a browser. Vertically minus degrees are facing upwards. The visible faces must be set in correct order. It is possible to do that by ordering faces by their average z-index, but I prefer not to complicate that process further. Z-sort will be used for sorting the cubes.
 
- code -
%(examples/rotate.py)s
- code -
 
A rotate function that rotates x-z horizontally, then y-z in vertical axis will be needed.
 
- code -
%(examples/xyz_on_canvas.py)s
- code -
 
A point in three-d should be rotated first. The values x-y will be the position on canvas. On canvas, the when the y is getting higher, it means it is being drawn to the end of canvas in vertical. So the height should be inreversed. I also scale them with a multipier in order to see the cube's borders. At the end, the scale may be minimized as less as possible. So the cubes won't be visible in result.
 
- code -
%(examples/darken.py)s
- code -
 
A darken function like above will be needed in order to make a cube's faces visually differentiable.
 
- code -
%(examples/render-1.py)s
- code -
 
I am using Python's PIL library for drawing in two-d. The render will be looking like below when we run it.
 
- code -
%(examples/render.py)s
- code -
 
The unit of width and height will be cubes.

image:/examples/render-1.png
 
Unit scale is too much for demonstration purpuse. It will be very less when using the cubes to create something that looks like not made of cubes. A bezier surface will be rendered with balls that mades of cubes.
 
- code -
%(examples/ball.py)s
- code -
 
It is easy to create a ball when we think a ball's radius is it's distance to the origin in a three-d space. The ball will be created in that way, starting at 0, 0, 0 origin.
 
- code -
%(examples/render-2.py)s
- code -
 
The result will be this.
 
image:/examples/render-2.png
 
A bezier surface is made of four bezier curves. Lets try to render a single bezier curve and complete the render process first.
 
- code -
%(examples/render-3.py)s
- code -
 
Cubes are sorted in their rendering order after the bezier interpolation.
 
image:/examples/render-3.png

Each interpolated point in four bezier curves, will be used for creating another curve. So in that way it will be possible shape a solid surface. A surface in this example has four curves and two properties, wide and fall. Wide is the one is longing, and fall is a curve that created by longing interpolated points.
 
- code -
%(examples/render-4.py)s
- code -
 
The result is looking like this.
 
image:/examples/render-4-3.png

Keeping the wide and tall parameters less, drawing lines between sparse points with their segments calculated by their distance may give better results. Lets try that.
 
- code -
%(examples/render-5.py)s
- code -
 
Next step, instead of showing the faces with balls made of cubes, finding the shaded color of a face by calculating the average of rendered cubes that stays in the area of it. It works well, plus it is possible to scale or see them in different angles without a need to build and render again. It may be possible to find shading of a face, without need to render them with cubes first, but I am afraid of doing that math. This is a painter's way to draw something on canvas, I prefer this way of rendering. Math stuff is not easy as it is written on black-white blackboard, and most likely the result is going to be disappointment.
 
image:/examples/render-6.png
 
image:/examples/render-6-1.png

- code -
%(examples/render-6.py)s
- code -
 
The render part is written in Python language. I edit the surfaces by an application that runs on a browser written with javascript when I am creating something. Here are some examples that I rendered in this way.
 
These are the examples with only cubes.
 
image:/examples/balconykarmelicka.png
 
image:/examples/sink.png
 
This is rendered with faces that painted by cubes.
 
image:/examples/potato.png
 
Good luck playing with that.
----
Syntax highlighting in Python
syntax-highlighting-in-python
I created a syntax highlighter to make my codes looking colorful in my blog. It is written in Python, so it does not require a Javascript code when the page is loaded. It is useful when you create html pages for documentation or a blog. Instead of making it packaged, I share the code piece, so it will be easer to modify when you find something missing.
 
- code -
%(syntax_highlighter.py)s
- code -
 

By seeking all the characters with index, for an index of an iterated character, the function like below will be helpful to understand how the current character is categorized.
 
- code -
def seek_token_by_char_index(tokens, char_index):
  for token in tokens:
    if char_index >= token["starts"] and char_index < token["ends"]:
      return token
- code -
 
Good luck playing with that.
----
SVG even odd rule
svg-even-odd-rule
Path on another path being subtracted sounds weird to me. I think they are constructed part by part. Deleting a part of a rendered thing, or rendering a path with excluding some parts of it by looking at another path needs twice more rendering time than doing it part by part. Boolean operations on such things are difficult things and I think it is not a solved thing in computer science. I think it is not science at all, it is some sort of pen and paper trick. Computer guys claim that it is possible than they compute it then delete one by one.
----
Comma separated values
comma-separated-values
I think it isn't a format. It is what it is. Domains are dot separated, URLs are slash seperated values so the something like a, b, c is comma separated values. Value is a thing that people are not being certain about. They are amperstand separated values that contains equals separated values something like that.
----
Interpolating a bezier curve
interpolating-a-bezier-curve
It is difficult to implement an interpolation of a bezier curve without seeing how it actually works. It requires too much attention to understand what is really happenning there. It is also difficult to find a clean implementation if you google that. You will most likely find an obfuscated version of a written clean code. So I am sharing a whole food with you.
 

- code -
def lerp(t, a, b):
  dx = b["x"] - a["x"]
  dy = b["y"] - a["y"]
  dz = b["z"] - a["z"]
  return {
    "x": a["x"] + t * dx,
    "y": a["y"] + t * dy,
    "z": a["z"] + t * dz
  }
 
def bezier(t, p0, p1, p2, p3):
  a = lerp(t, p0, p1)
  b = lerp(t, p1, p2)
  c = lerp(t, p2, p3)
  d = lerp(t, a, b)
  e = lerp(t, b, c)
  f = lerp(t, d, e)
  return f
- code -
 
Good luck playing with this.